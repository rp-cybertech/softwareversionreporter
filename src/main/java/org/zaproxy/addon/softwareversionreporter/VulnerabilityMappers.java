/*
 * Zed Attack Proxy (ZAP) and its related class files.
 *
 * ZAP is an HTTP/HTTPS proxy for assessing web application security.
 *
 * Copyright 2025 The ZAP Development Team
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.zaproxy.addon.softwareversionreporter;

import com.fasterxml.jackson.databind.JsonNode;
import java.util.ArrayList;
import java.util.List;
import org.zaproxy.addon.softwareversionreporter.model.EnrichmentResult.VulnerabilityInfo;

public final class VulnerabilityMappers {
    private VulnerabilityMappers() {}

    public static VulnerabilityInfo mapNvdCve(JsonNode cve) {
        VulnerabilityInfo v = new VulnerabilityInfo();
        String id = cve.path("id").asText("");
        v.setCveId(id);
        if (cve.path("descriptions").isArray()) {
            for (JsonNode d : cve.path("descriptions")) {
                if ("en".equalsIgnoreCase(d.path("lang").asText())) {
                    v.setShortDescription(d.path("value").asText(""));
                    break;
                }
            }
        }
        double score = 0.0;
        String severity = "";
        JsonNode m31 = cve.path("metrics").path("cvssMetricV31");
        JsonNode m30 = cve.path("metrics").path("cvssMetricV30");
        JsonNode m2 = cve.path("metrics").path("cvssMetricV2");
        if (m31.isArray() && m31.size() > 0) {
            score = m31.get(0).path("cvssData").path("baseScore").asDouble(0.0);
            severity = m31.get(0).path("cvssData").path("baseSeverity").asText("");
        } else if (m30.isArray() && m30.size() > 0) {
            score = m30.get(0).path("cvssData").path("baseScore").asDouble(0.0);
            severity = m30.get(0).path("cvssData").path("baseSeverity").asText("");
        } else if (m2.isArray() && m2.size() > 0) {
            score = m2.get(0).path("cvssData").path("baseScore").asDouble(0.0);
            severity = m2.get(0).path("cvssData").path("baseSeverity").asText("");
        }
        
        // Default unknown/unmapped vulnerabilities to LOW
        if (severity == null || severity.isBlank()) {
            severity = "LOW";
        }
        
        v.setCvssScore(score);
        v.setSeverity(severity);
        v.setLink("https://nvd.nist.gov/vuln/detail/" + id);
        v.setTitle(id.isEmpty() ? "Vulnerability" : id);
        return v;
    }

    public static VulnerabilityInfo mapVulnersItem(JsonNode item) {
        JsonNode src = item.has("_source") ? item.path("_source") : item;
        VulnerabilityInfo v = new VulnerabilityInfo();
        
        // Extract title
        String title = src.path("title").asText("");
        
        // Extract description - try multiple fields
        String desc = src.path("description").asText("");
        if (desc.isEmpty()) {
            desc = src.path("summary").asText("");
        }
        if (desc.isEmpty()) {
            desc = src.path("snippet").asText("");
        }
        
        // Extract link
        String link = src.path("href").asText("");
        if (link.isEmpty()) {
            // Try to build link from CVE ID
            JsonNode cveList = src.path("cvelist");
            if (cveList.isArray() && cveList.size() > 0) {
                String cveId = cveList.get(0).asText("");
                if (!cveId.isEmpty() && cveId.startsWith("CVE-")) {
                    link = "https://vulners.com/cve/" + cveId;
                }
            }
        }
        
        // Extract CVE ID
        String cve = null;
        JsonNode cveList = src.path("cvelist");
        if (cveList.isArray() && cveList.size() > 0) {
            cve = cveList.get(0).asText(null);
        }
        if (cve == null && src.has("id")) {
            String id = src.path("id").asText("");
            if (id.startsWith("CVE-")) {
                cve = id;
            }
        }
        
        // Extract CVSS score and severity - only use API-provided severity, don't calculate from score
        double score = 0.0;
        String severity = "";
        JsonNode cvssNode = src.path("cvss");
        if (!cvssNode.isMissingNode()) {
            if (cvssNode.has("score")) {
                score = cvssNode.path("score").asDouble(0.0);
            } else {
                score = cvssNode.asDouble(0.0);
            }
            // Only use severity if explicitly provided by API - don't calculate from CVSS score
            if (cvssNode.has("severity")) {
                severity = cvssNode.path("severity").asText("");
            }
        }
        
        // Check for severity in other common locations
        if (severity.isEmpty() && src.has("severity")) {
            severity = src.path("severity").asText("");
        }
        if (severity.isEmpty() && src.has("baseSeverity")) {
            severity = src.path("baseSeverity").asText("");
        }
        
        // Default ALL unknown/unmapped/missing severities to LOW (never calculate from CVSS score)
        if (severity == null || severity.isBlank()) {
            severity = "LOW";
        }
        
        // Set vulnerability info
        if (cve != null && !cve.isEmpty()) {
            v.setCveId(cve);
            v.setTitle(title.isEmpty() ? cve : title);
        } else {
            // Use Vulners ID if no CVE
            String vulnersId = src.path("id").asText("VULNERS");
            v.setCveId(vulnersId);
            v.setTitle(title.isEmpty() ? vulnersId : title);
        }
        
        v.setShortDescription(desc.isEmpty() ? title : desc);
        v.setDescription(desc);
        v.setLink(link.isEmpty() ? null : link);
        v.setCvssScore(score);
        v.setSeverity(severity);
        
        // Set source
        v.setFamily("Vulners");
        v.setRecordType(src.path("type").asText("cve"));
        
        return v;
    }

    public static VulnerabilityInfo mapVuldbEntry(JsonNode entry) {
        VulnerabilityInfo v = new VulnerabilityInfo();
        
        // Extract VulDB entry ID
        String vuldbId = entry.path("entry").path("id").asText("");
        String title = entry.path("entry").path("title").asText("");
        
        // Extract CVE ID from source.cve.id or alternative locations
        String cve = entry.path("source").path("cve").path("id").asText("");
        if (cve.isEmpty()) {
            // Try alternative paths
            cve = entry.path("cve").path("id").asText("");
        }
        if (cve.isEmpty() && entry.has("cvelist") && entry.path("cvelist").isArray()) {
            JsonNode cveList = entry.path("cvelist");
            if (cveList.size() > 0) {
                cve = cveList.get(0).asText("");
            }
        }
        
        // Build link
        String link = "";
        if (!vuldbId.isEmpty()) {
            link = "https://vuldb.com/?id." + vuldbId;
        }
        
        // Extract risk/severity information
        String severity = "";
        JsonNode riskNode = entry.path("vulnerability").path("risk");
        if (!riskNode.isMissingNode()) {
            severity = riskNode.path("name").asText("").toUpperCase();
        }
        
        // Get CVSS score
        double score = 0.0;
        JsonNode vulnNode = entry.path("vulnerability");
        if (!vulnNode.isMissingNode()) {
            JsonNode cvssNode = vulnNode.path("cvss");
            if (!cvssNode.isMissingNode()) {
                // Try CVSS v3 first, then v2
                if (cvssNode.has("v3")) {
                    score = cvssNode.path("v3").path("baseScore").asDouble(0.0);
                } else if (cvssNode.has("v2")) {
                    score = cvssNode.path("v2").path("baseScore").asDouble(0.0);
                }
            }
        }
        
        // Default unknown/unmapped vulnerabilities to LOW (never calculate from CVSS score)
        if (severity == null || severity.isBlank()) {
            severity = "LOW";
        }
        
        // Set CVE ID (prefer CVE, fallback to VULDB-ID)
        if (!cve.isEmpty()) {
            v.setCveId(cve);
        } else if (!vuldbId.isEmpty()) {
            v.setCveId("VULDB-" + vuldbId);
        } else {
            v.setCveId("VULDB");
        }
        
        v.setTitle(title.isEmpty() ? v.getCveId() : title);
        v.setShortDescription(title);
        v.setDescription(title);
        v.setLink(link.isEmpty() ? null : link);
        v.setCvssScore(score);
        v.setSeverity(severity);
        
        // Extract references
        JsonNode refsNode = entry.path("references");
        if (refsNode.isArray() && refsNode.size() > 0) {
            List<String> refs = new ArrayList<>();
            for (JsonNode r : refsNode) {
                if (r.isTextual()) {
                    refs.add(r.asText());
                } else if (r.has("url")) {
                    refs.add(r.path("url").asText());
                }
            }
            v.setReferences(refs);
        }
        
        v.setFamily("VulDB");
        v.setRecordType("vulnerability");
        
        return v;
    }
}
